
"""High level wrappers for wrapping auto-swig-generated code."""

#
# still import the fli._* stuff with this.
#
import flume_internal as fli
import flume
import posix
import errno
import os
import struct

##-----------------------------------------------------------------------

def raise_err (s=None):
    """Raise an error based on what the global Flume Error flag
    reported was the error."""

    if s is None:
        s = ""
    
    if flume.get_errno () == flume.ENOMEM:
        raise MemoryError, "out of memory in flumeclient code"
    elif flume.get_errno () == flume.ENULL:
        raise ValueError, "NULL value encountered"
    elif flume.get_errno () == flume.EPERM:
        ss = []
        if (s):
            ss.append (s)
        s2 = flume.get_errstr ()
        if (s2):
            ss.append (s2)
        if len(ss) > 0:
            s = '; '.join (ss)
        else:
            s = "permission denied"
        raise flume.PermissionError, s
    elif flume.get_errno () == flume.EINVAL:
        raise ValueError, "Unexpected valued encountered: '%s'" %s
    elif flume.get_errno () == flume.ERANGE:
        raise IndexError, "Value out of range"
    elif flume.get_errno () == flume.EHANDLE:
        raise flume.HandleError, "Could not parse handle: '%s'" % s
    elif flume.get_errno () == flume.ECAPABILITY:
        raise flume.CapabilityError, "Expected a capability"
    elif flume.get_errno () == flume.EROFS:
        raise flume.ReadOnlyError, "Attempted write to read-only FS"
    elif flume.get_errno () == flume.EEXPIRED:
        raise flume.ExpirationError, "expiration encountered"
    elif flume.get_errno () == flume.EATTR:
        raise flume.ExtattrError, "Extended attributes error encountered"
    elif flume.get_errno () == flume.EPERSISTENCE:
        raise flume.PersistenceError, "Persistence error encountered: %s" % s
    else:
        ec = flume.sysErrno ()
        if ec is not None:
            raise OSError (ec, s)
        else:
            raise Exception, ("Unhandled flume error (%s) on %s" % \
                              (str (flume.get_errno ()), s))

##-----------------------------------------------------------------------

class Callable:
    def __init__(self, anycallable):
        self.__call__ = anycallable

##-----------------------------------------------------------------------

def orderBits (bitset, order):
    """Given a bitset and a canonical ordering, return the set bits in the
    given order."""
    ret = []
    for b in order:
        if b & bitset != 0:
            ret += [ b ]
    return ret


##-----------------------------------------------------------------------

class Argv (fli._Argv):
    """A wrapper around char *argv[] things that you'll see passed to
    execve and so on."""

    def __init__ (self, l):
        if l is None:
            fli._Argv.__init__ (self, -1)
        elif type(l) is list:
            self.init_from_list (l)
        else:
            self.init_from_dict (l)

    def init_from_dict (self, d):
        l = [ str(k) + "=" + str (d[k]) for k in d.keys () ]
        self.init_from_list (l)

    def init_from_list (self, l):
        fli._Argv.__init__ (self, len (l))
        i = 0
        for a in l:
            self._set (i, a)
            i += 1

##-----------------------------------------------------------------------

class RawData (fli._RawData):
    """A wrapper class around raw XDR data."""
    def __init__ (self, dat = None, armored = False):
        fli._RawData.__init__ (self)
        if type (dat) is str:
            if armored:
                self.dearmor (dat)
            else:
                if self._init (dat) < 0:
                    raise_err ("error in RawData allocation");
        elif isinstance (dat, fli._RawData):
            if self._copy (dat) < 0:
                raise_err ("failed to copy RawData in constructor")
        elif dat is not None:
            raise TypeError, "wrong type to RawData()"

    def __eq__ (self, x):
        return isinstance (x, fli._RawData) and self._eq (x)

    def dearmor (self, s):
        if type (s) is not str:
            raise TypeError, "Can only dearmor a string"
        if self._dearmor (s) < 0:
            raise_err ("Cannot dearmor given string")
        return self


##-----------------------------------------------------------------------

class Token (fli._Token):
    """A wrapper class around the autogenerated Swig Tokens."""

    def __init__ (self, s):
        fli._Token.__init__ (self, s)

    def dearmor (self, s):
        if fli._Token.dearmor (self, s) < 0:
            raise_err ("dearmor Token")

##-----------------------------------------------------------------------

class Handle (fli._Handle):
    """A wrapper class around an autogenerated-Swig handle, to
    iterface with some Python-specific features."""

    # default value can't be None, since that's an error result
    # from some syscalls
    def __init__(self, x = 0, nm = None):
        fli._Handle.__init__ (self, 0, None)
        if x is None:
            raise_err ("handle failure")
        elif isinstance (x, fli._Handle):
            self._init (x.val (), x.name ())
        elif type(x) is long or type(x) is int:
            self._init (x, nm)
        elif isinstance (x, fli._RawData):
            self.fromRaw (x)
        elif type (x) is str:
            h = Handle ()
            h.dearmor32(x)
            self._init (h.val (), nm)
        else:
            raise TypeError, "Bad arguments to constructor"

    def fromRaw (self, x):
        if self._from_raw (x) < 0:
            raise_err ("Cannot convert handle from raw repr")
    def toRaw (self):
        return RawData (self._to_raw ())

    def thaw (self):
        return Label (fli._thaw_handle (self))

    def __str__ (self):
        """Convert a handle to a human-readable string."""
        if self.name () is not None:
            return self.name () + " (0x%016x)" % self.val ()
        else:
            return "0x%016x" % self.val ()

    def dearmor32(self, s):
        """Dearmor a given handle."""
        rc = self._dearmor32 (s)
        if rc < 0:
            raise_err (flume.get_errstr ())

    def toCapability (self, opt):
        return Handle (self._to_capability (opt))

    def toCapabilities (self):
        # Figure out what type of handle this is, and return a list of
        # the corresponding capabilities

        m = ((flume.HANDLE_OPT_GROUP, [flume.CAPABILITY_GROUP_SELECT]),
             (flume.HANDLE_OPT_DEFAULT_ADD, [flume.CAPABILITY_SUBTRACT]),
             (flume.HANDLE_OPT_DEFAULT_SUBTRACT, [flume.CAPABILITY_ADD]),
             (0, [flume.CAPABILITY_ADD, flume.CAPABILITY_SUBTRACT]))

        all_opts = reduce (lambda x,y: x|y, [z[0] for z in m])

        for opt, caps in m:
            if (self.prefix () & all_opts) == opt:
                return [self.toCapability (cap) for cap in caps]

        raise ValueError ("%s does not look like a valid capability" % (self,))
    
    def toTag (self):
        """Return a Handle with the Capability bits cleared"""

        # If it's a wrap capability, return self.
        if ((self.prefix () & (flume.CAPABILITY_GROUP_SELECT | flume.HANDLE_OPT_IDENTIFIER)) ==
            flume.CAPABILITY_GROUP_SELECT | flume.HANDLE_OPT_IDENTIFIER):
            return self

        # otherwise, clear the capability bits
        xhandle = Handle.mk ( ~(flume.CAPABILITY_ADD |
                                flume.CAPABILITY_SUBTRACT |
                                flume.CAPABILITY_GROUP_SELECT) & self.prefix (),
                              self.base ())
        return Handle (xhandle)

    def __hash__ (self):
        return hash (self.val ())

    def __eq__ (self, other):
        return self.val () == other.val ()

    def __ne__ (self, other):
        return not self.__eq__ (other)

##-----------------------------------------------------------------------

class Int (fli._Int):
    """A wrapper class around an Int, for the purposes of making an 
    array of ints..."""

    def __init__ (self, x = 0):
        if x is None:
            raise_err ("int failure")

        if isinstance (x, fli._Int):
            v = x.val ()
        elif type (x) is long or type (x) is int:
            v = x
        elif type (x) is str:
            v = int (x)
        else:
            raise TypeError, "Bad arguments to constructor"

        fli._Int.__init__ (self, v)

    def __str__ (self):
        return "%d" % self.val ()

    def to_int (self):
        return self.val ()


##-----------------------------------------------------------------------

class _PyObjSetWrapperIter:
    """A simple iterator for _PyObjSetWrappers."""

    def __init__ (self, osw):
        self._osw = osw
        self._i = 0

    def next (self):
        i = self._i
        if i >= len (self._osw):
            raise StopError
        self._i =+ 1
        return self._osw.get (i)


##-----------------------------------------------------------------------

class _PyObjSetWrapper:
    """A layer that goes between python objects and C++ Swig objects
    derived from _ObjSetWrapper<>."""

    def __init__ (self, obj, py_class, swig_class, py_obj_class, name):
        self._py_class = py_class
        self._swig_class = swig_class
        self._py_obj_class = py_obj_class
        self._class_name = name
        self._swig_class.__init__ (self)

        if obj is None:
            raise_err ("%s allocation failure" % name)
        elif type (obj) is self._swig_class:
            self.copy (obj)
        elif isinstance (obj, fli._RawData):
            self.fromRaw (obj)
        elif type (obj) is set:
            self.fromList (list (obj))
        elif type (obj) is list or type (obj) is tuple:
            self.fromList (obj)
        elif type (obj) is int:
            if obj >= 0:
                self.resize (obj)
        else:
            raise TypeError, "bad argument to constructor"

    def __iter__ (self):
        return _PyObjSetWrapperIter (self)

    def __len__ (self):
        return self._size ()

    def size (self):
        return self._size ()

    def clone (self):
        return self._py_class (self._clone ())

    def get (self, i):
        return self._py_obj_class (self._get (i))

    def copy (self, i):
        if self._copy (i) < 0:
            raise_err ("%s::copy" % self._class_name)

    def resize (self, i):
        if self._resize (i) < 0:
            raise_err ("%s::resize" % self._class_name)

    def set (self, i, l):
        if self._set (i, l) < 0:
            raise_err ("%s::set" % self._class_name)

    def fromList (self, l):
        self.resize (len (l))
        for i, o in enumerate (l):
            self.set (i, o)

    def toList (self):
        return [ self.get (i) for i in range (len(self)) ]

    def fromRaw (self, d):
        if self._from_raw (d) < 0:
            raise_err ("Error converting object from raw data")
    def toRaw (self):
        return RawData (self._to_raw ())

    def __str__ (self):
        return str ([ str(x) for x in self.toList() ])

    def __getitem__ (self, key):
        l = self.toList ()
        return l[key]

    def __setitem__ (self, key, value):
        l = self.toList ()
        l[key] = value
        self.fromList (l)

    def __delitem__ (self, key):
        l = self.toList ()
        del (l[key])
        self.fromList (l)

    def __iter__ (self):
        return iter (self.toList ())

    def __contains__ (self, item):
        return self.toList().__contains__(item)

    def _add_ready_list (self, l):
        if isinstance(l, self._py_obj_class):
            l = [l]
        elif isinstance (l, self._py_class):
            l = l.toList ()
        elif type (l) is list:
            for i in l:
                if not isinstance (i, self._py_obj_class):
                    raise TypeError, "expected a list of type: %s" % \
                        str (self._py_obj_class)
        else:
            raise TypeError, "cannot add type to list: %s + $s" % \
                (str (self), str (l))
        return l

    def __add__ (self, l):
        l = self._add_ready_list (l)
        return (self._py_class (self.toList () + l))

    def __iadd__ (self, l):
        l = self._add_ready_list (l)
        self.fromList (self.toList () + l)
        return self

    def __sub__ (self, l):
        s = set (self._add_ready_list (l))
        return (self._py_class (set(self.toList ()) - s))

    def __isub__ (self, l):
        s = set (self._add_ready_list (l))
        self.fromList (set(self.toList ()) - s)
        return self

##-----------------------------------------------------------------------

class IntArr (_PyObjSetWrapper, fli._IntArr):

    def __init__ (self, x = 0):
        _PyObjSetWrapper.__init__ (self, x, IntArr, fli._IntArr, Int, "IntArr")

    def set (self, i, x):
        if type (x) is int or type (x) is long:
            x = Int (x)
        _PyObjSetWrapper.set (self, i, x)

    def toListV (self):
        return [ x.val() for x in self.toList() ]

##-----------------------------------------------------------------------


class Label (_PyObjSetWrapper, fli._Label):
    """A wrapper class around an autogenerated-Swig label, to
    interface with some Python-specific features."""

    # default value can't be None, since that's an error result from
    # _get_label()
    def __init__(self, x = 0):
        _PyObjSetWrapper.__init__ (self, x, Label, fli._Label,
                                   Handle, "Label")
    def uniquify (self, seq):
        """ Preserves order """
        seen = set()
        return [x for x in seq if x not in seen and not seen.add(x)]

    # Overload fromList and fromRaw to remove duplicates
    def fromList (self, l):
        l2 = self.uniquify (l)
        _PyObjSetWrapper.fromList (self, l2)

    def fromRaw (self, d):
        _PyObjSetWrapper.fromRaw (self, d)
        l = self.uniquify (self.toList ())
        self.fromList (l)

    def __lt__ (self, b):
        return self.toSet().__lt__(b.toSet())
    def __le__ (self, b):
        return self.toSet().__le__(b.toSet())
    def __eq__ (self, b):
        return self.toSet().__eq__(b.toSet())
    def __ne__(self, b):
        return self.toSet().__ne__(b.toSet())
    def __gt__ (self, b):
        return self.toSet().__gt__(b.toSet())
    def __ge__ (self, b):
        return self.toSet().__ge__(b.toSet())

    def subsetOf (self, rhs, typ):
        r = fli._subsetOf (self, LabelVec (rhs), typ)
        if r < 0:
            raise_err ()
        if r == 0:
            return False
        return True

    def freeze (self):
        return Handle (fli._Label_freeze (self))

    def __str__(self):
        return "[" + ", ".join ([str(s) for s in self.toList ()]) + "]"

    def toListV (self):
        return [ x.val() for x in self.toList() ]

    def toSet (self):
        return set (self.toListV())

    def __contains__(self, h):
        if type(h) is int or type(h) is long:
            v = h
        else:
            v = h.val()
        return v in self.toSet ()

    def pack (self):
        l = self.toListV ()
        l.sort ()
    
        format = '!' + 'Q' * len (l)
        l.insert (0, format)
        return struct.pack (*l)

    def unpack (s):
        if (len (s) % struct.calcsize ('Q')) > 0:
            raise AssertionError, ('serialized label, incorrect '
                                   'size %d is not a multiple of %d'
                                   % (len (s), struct.calcsize ('Q')))
        format = '!' + 'Q' * (len(s)/struct.calcsize ('Q'))
        v = struct.unpack (format, s)
        return Label ([Handle (x) for x in v])

    unpack = Callable (unpack)

    def hashkey (self):
        """ Returns a canonicalized string that can be used as a hash
        key.  We don't implement __hash__ because a labelset is
        mutable and implementing __hash__ implies that the underlying
        object is immutable."""
        values = self.toList ()
        values.sort (key=lambda h: h.val ())
        return "[" + ", ".join ([str(s) for s in values]) + "]"


##-----------------------------------------------------------------------

class LabelVec (fli._LabelVec):
    """A wrapper class used as an input to subsetOf operations."""
    def __init__ (self, labels):
        fli._LabelVec.__init__(self, len(labels))
        i = 0
        for l in labels:
            self._set (i, l)
            i += 1

##-----------------------------------------------------------------------
        
class Filter (fli._Filter):
    """A wrapper class around filters."""
    def __init__ (self, f):
        fli._Filter.__init__ (self)
        if type (f) is fli._Filter:
            if self.copy (f) < 0:
                raise_err ("copy Filter")
        else:
            raise TypeError, "bad argument to constructor"

    def find (self):
        return Label (fli._Filter.find (self))
    def replace (self):
        return Label (fli._Fitler.replace (self))

##-----------------------------------------------------------------------
    
class Capset (Label):
    """A type of label specifically designed for storing capabilities."""
    
    def __init__ (self, l, priv):
        Label.__init__ (self, [ x.toCapability (priv) for x in l.toList() ] )

##-----------------------------------------------------------------------

class Endpoint (fli._Endpoint):
    """A high-level wrapper to the _Endpoint autogenerated by Swig."""

    def __init__ (self, ep = -1, I = None, S = None):
        fli._Endpoint.__init__(self)
        if ep is None:
            raise_err ("Endpoint failure")
        elif type(ep) is fli._Endpoint:
            if self.copy (ep) < 0:
                raise_err ("Endpoint copy failure")
        elif type(ep) is int and ep == -1:
            if I is not None:
                fli._Endpoint._set_I (self, I)
            if S is not None:
                fli._Endpoint._set_S (self, S)
        else:
            raise TypeError, "bad argument to constructor"

    def get_S (self):
        return Label (self._get_S())

    def get_I (self):
        return Label (self._get_I())

    def get_desc (self):
        ret = self._get_desc ()
        if ret is None:
            ret = "<none>"
        else:
            ret = str (ret)
        return ret
        

    def toDict (self):
        d = { 'readable' :    bool (self.getReadable ()),
              'writable' :    bool (self.getWritable ()),
              'mutable'  :    bool (self.getMutable ()),
              'I'        :    self.get_I(),
              'S'        :    self.get_S(),
              'desc'     :    self.get_desc ()
              }
        return d

    def attrStr (self):
        l = [ ('r', self.getReadable ()),
              ('w', self.getWritable ()),
              ('m', self.getMutable ()) ]
        r = ""
        for t in l:
            if t[1]:
                r += t[0]
        return r

    def prettyPrint (self, prfx = ""):
        
        pairs = [ ( 'S:    ' , self.get_S () ),
                  ( 'I:    ' , self.get_I () ),
                  ( 'attrs:' , self.attrStr () ),
                  ( 'desc: ' , self.get_desc () ) ]

        # XXX allow endpoints to be named, too
        lines = [ "Endpoint {" ] + \
                [ "  %s %s" % (t[0], t[1]) for t in pairs ] + \
                [ "}" ]

        return '\n'.join ( [ "%s%s" % (prfx, l) for l in lines ] )

    def __str__(self):
        return str (dict ([ (k,str (v)) for (k,v) in self.toDict().items()]))

    def getMutable (self):
        return bool (self._get_mutable ())
    def getWritable (self):
        return bool (self._get_writable ())
    def getReadable (self):
        return bool (self._get_readable ())
    def setReadable (self, b):
        self._set_reable (int (b))
    def setWritable (self, b):
        self._set_writable (self, int (b))
    def setMutable (self, b):
        self._set_mutable (self, int (b))

##-----------------------------------------------------------------------

class EndpointSet (_PyObjSetWrapper, fli._EndpointSet):
    """A high-level wrapper around Endpoint sets autogenerated by Swig."""

    def __init__ (self, eps = 0):
        _PyObjSetWrapper.__init__ (self, eps,
                                   EndpointSet,
                                   fli._EndpointSet,
                                   Endpoint,
                                   "EndpointSet")

    def prettyPrint (self):
        lst = [ "EndpointSet {" ] + \
              [ x.prettyPrint ("  ") for x in self.toList ()] + \
              [ "}" , '' ]
        return '\n'.join (lst)

##-----------------------------------------------------------------------

class LabelSet (fli._LabelSet):
    """A high-level wrapper to the LabelSet autogenerated by Swig."""

    # When make label changes from this LabelSet, do it in this
    # order. Alex suggests this order.
    change_order = [flume.LABEL_O, flume.LABEL_I, flume.LABEL_S]

    def __init__(self, ls = -1, I = None, S = None, O = None, armoredraw=False):
        fli._LabelSet.__init__(self)
        if ls is None:
            raise_err ("LabelSet failure")
        elif type(ls) is dict:
            for l in [ ("I", fli._LabelSet._set_I),
                       ("S", fli._LabelSet._set_S),
                       ("O", fli._LabelSet._set_O) ] :
                try:
                    f = l[1]
                    f (self, ls[l[0]])
                except KeyError:
                    pass
        elif isinstance (ls, fli._LabelSet):
            self.copy (ls)
        elif isinstance (ls, fli._RawData):
            self.fromRaw (ls)
        elif type(ls) is int and ls == -1:
            if I is not None:
                fli._LabelSet._set_I (self, I)
            if S is not None:
                fli._LabelSet._set_S (self, S)
            if O is not None:
                fli._LabelSet._set_O (self, O)
        elif type (ls) is type ('a'):
            if armoredraw:
                rd = RawData (ls, True)
                self.fromRaw (rd)
            else:
                ls = fli._filename_to_labelset (ls)
                self.copy (ls)
        else:
            raise TypeError, "bad argument to constructor"

    def __le__ (self, b):
        return self.get_S() <= b.get_S() and b.get_I() <= self.get_I()
    def __ge__ (self, b):
        return self.get_S() >= b.get_S() and b.get_I() >= self.get_I()
    def __eq__ (self, b):
        return self.get_S() == b.get_S() and b.get_I() == self.get_I()
    def __ne__ (self, b):
        return self.get_S() != b.get_S() or b.get_I() != self.get_I()
    def __gt__ (self, b):
        return self.get_S() > b.get_S() and b.get_I() > self.get_I()
    def __lt__ (self, b):
        return self.get_S() < b.get_S() and b.get_I() < self.get_I()

    def toDict (self):
        return { "I" : self.get_I (),
                 "S" : self.get_S (),
                 "O" : self.get_O () }

    def toDictEnumKeys (self):
        return { flume.LABEL_I : self.get_I (),
                 flume.LABEL_S : self.get_S (),
                 flume.LABEL_O : self.get_O () }

    def toLabelChangeList (self, which = flume.LABEL_ALL):
        ret = []
        d = self.toDictEnumKeys ()

        for i in orderBits (which, self.change_order):
            if d[i] is not None:
                ret += [ LabelChange (lab = d[i], which = i) ]
                
        return ret

    def apply (self):
        LabelChangeSet (self.toLabelChangeList ()).make ()
    def apply_ep (self, fd):
        LabelChangeSet (self.toLabelChangeList (flume.LABEL_NO_O)).make_ep (fd)
        
    def set_S (self, l=None):
        if self._set_S (l) < 0:
            raise_err ("label = %s" % l)
    def set_I (self, l=None):
        if self._set_I (l) < 0:
            raise_err ("label = %s" % l)
    def set_O (self, l=None):
        if self._set_O (l) < 0:
            raise_err ("label = %s" % l)
    def set_label (self, typ, l=None):
        return { flume.LABEL_I : self.set_I,
                 flume.LABEL_S : self.set_S,
                 flume.LABEL_O : self.set_O }[typ] (l)

    def get_S (self):
        return Label (self._get_S ())
    def get_I (self):
        return Label (self._get_I ())
    def get_O (self):
        return Label (self._get_O ())
    def get_label (self, typ):
        return self.toDictEnumKeys ()[typ]

    def __str__(self):
        return str (dict ([ (k,str(v)) for (k,v) in self.toDict().items() ]))

    def to_filename (self):
        if len(self.get_S ()) == 0 and len(self.get_I()) == 0 and \
               len(self.get_I ()) == 0:
            return "0"
        
        ret = self._to_filename ()
        if ret is None:
            raise_err ("labelset_to_filename")
        return ret

    def toList (self):
        return [self._get_S (), self._get_I (), self._get_O () ]

    def fromRaw (self, obj):
        if self._from_raw (obj) < 0:
            raise_err ("Error converting object from raw data")
    def toRaw (self):
        return RawData (self._to_raw ())

    def armoredraw (self):
        return self.toRaw ().armor ()

    def hashkey (self):
        """ Returns a canonicalized string that can be used as a hash
        key.  We don't implement __hash__ because a labelset is
        mutable and implementing __hash__ implies that the underlying
        object is immutable."""
        ret = [Label(lab).hashkey() for lab in self.toList ()]
        return str(ret)

    def clone (self):
        ls = LabelSet ()
        ls.copy (self)
        return ls

##-----------------------------------------------------------------------

class LabelChange (fli._LabelChange):
    """A high-level wrapper around _LabelChange generated by swig."""

    def __init__ (self, lab = None, which = fli.LABEL_NONE):
        """lab can be either a LabelChange or a Label object, and this
        construction should do the right thing.  Pass a LabelChange as
        part a copy constructor, and pass a Label if calling from somewhere
        external to this function."""
        fli._LabelChange.__init__ (self)
        if lab is not None:
            if type (lab) is fli._LabelChange:
                self.copy (lab)
            else:
                self.setLabel (lab)
                if which is not None:
                    self.setWhich (which)

    def getWhich (self):
        return fli._LabelChange.get_which (self)

    def setWhich (self, i):
        return fli._LabelChange.set_which (self, i)

    def clone (self):
        """Make a clone of this label change."""
        return LabelChange (fli._LabelChange.clone (self))

    def setLabel (self, l):
        """Set the label on LabelChange object"""
        if fli._LabelChange._set_label (self, l) < 0:
           raise_err ("LabelChange::set_label")

    def getLabel (self):
        return Label (self._get_label ())

    def copy (self, l):
        if fli._LabelChange._copy (self, l) < 0:
            raise_err ("LabelChange::copy")

    def __str__ (self):
        return str ((str (self.getLabel ()), self.getWhich ()))

    def make (self):
        """Actually make this label change."""
        set_label (self.getWhich (), self.getLabel ())
    def make_ep (self, fd):
        """Actually make this label change to an endpoint."""
        set_fd_label (self.getWhich (), fd, self.getLabel ())


##-----------------------------------------------------------------------

class LabelChangeSet (_PyObjSetWrapper, fli._LabelChangeSet):
    """A high level wrapper around _LabelChangeSet generated by Swig."""
    
    def __init__ (self, lcs = []):
        _PyObjSetWrapper.__init__ (self, lcs,
                                   LabelChangeSet,
                                   fli._LabelChangeSet, 
                                   LabelChange,
                                   "LabelChangeSet")

    def _add_arg_to_label_change_list (self, l):
        """Convert the argument to __add__ or __iadd__ to be a list of
        label changes."""
        if type (l) is list:
            l2 = l
        elif isinstance (l, LabelChangeSet):
            l2 = l.toList ()
        elif isinstance (l, LabelSet):
            l2 = l.toLabelChangeList ()
        else:
            raise TypeError, \
                  "arg to +/+= must be list, LabelChangeSet or LabelSet"
        return l2

    def __add__ (self, l):
        """Add more label changes to this label change set, without
        destructively changing it."""
        l1 = self.toList ()
        l2 = self._add_arg_to_label_change_list (l)
        return LabelChangeSet (l1 + l2)

    def make (self):
        """Make the label changes contained in this label set."""
        for l in self.toList ():
            l.make ()
    def make_ep(self, fd):
        """Make the label chagnes to the EP."""
        for l in self.toList ():
            l.make_ep(fd)

    def __iadd__ (self, l):
        """Add more label changes to this label change set, and alter
        the underlying LabelChangeSet."""
        l2 = self._add_arg_to_label_change_list (l)

        oldlen = len(self)
        self.resize (oldlen + len (l2))
        for i,obj in enumerate (l2):
            self.set (oldlen + i, obj)
        
        return self

##-----------------------------------------------------------------------

class CapabilityOp (fli._CapabilityOp):
    """A high-level wrapper around a capability operation that we have
    in the SQL library."""

    def __init__ (self, h, op=None):
        fli._CapabilityOp.__init__ (self)
        if isinstance(h, fli._CapabilityOp):
            op = h._get_op ()
            h = Handle (h._get_h ())
        self.set_h (h)
        self.set_op (op)

    def __str__ (self):
        return "(%s,%d)" % (str (self.get_h ()), self.get_op ())
    def set_h (self, h):
        self._set_h (h)
    def set_op (self, op):
        self._set_op (op)
    def get_h (self):
        return Handle (self._get_h ())
    def get_op (self):
        return self._get_op ()
    def toPair (self):
        return (self.get_h (), self.get_op ())

##-----------------------------------------------------------------------

class CapabilityOpSet (_PyObjSetWrapper, fli._CapabilityOpSet):
    
    def __init__ (self, cos = None):
        _PyObjSetWrapper.__init__ (self, cos,
                                   CapabilityOpSet,
                                   fli._CapabilityOpSet,
                                   CapabilityOp,
                                   "CapabilityOpSet")

    def toDict (self):
        return dict ([ cop.toPair () for cop in self ] )
            
##-----------------------------------------------------------------------
##-----------------------------------------------------------------------
##-----------------------------------------------------------------------
            
def set_label (typ, label=None, frc=True):
    """Set the processes label to the give label. 'typ' should be one
    of flume.LABEL_I, flume.LABEL_S, or flume.LABEL_O, and the 'label'
    argument should be a flmos.Label object.  If given None, we will try
    to clear the label.  On success no return code; on error, raise an
    exception."""
    
    if fli._set_label (typ, label, frc) < 0:
        raise_err ("set_label failed")

##-----------------------------------------------------------------------

def set_label2 (O = -1, I = -1, S = -1, frc=True):
    """A slightly more convenient way to set this proc's label.  Perform
    in the order: O, I, S, as per standard.  Note, the -1 hack is because
    None are allowed as label types, if we want to clear the label."""
    dat = [ ( flume.LABEL_O, O),
            ( flume.LABEL_I, I),
            ( flume.LABEL_S, S) ]
    for p in dat:
        if p[1] is None or isinstance (p[1], Label):
            if fli._set_label (p[0], p[1], frc) < 0:
                raise_err ("set_label failed")
        elif (type(p[1]) == type(-1)) and p[1] == -1:
            pass
        else:
            raise TypeError, 'Invalid argument type to set_label2'

##-----------------------------------------------------------------------

def set_fd_label (typ, fd, label=None):
    """Set a label on the given 'fd'.  Provide an 'fd' in addition to the
    arguments from set_label."""
    if fli._set_fd_label (typ, fd, label) < 0:
        raise_err ("set_fd_label failed")

##-----------------------------------------------------------------------

def get_label (typ):
    """Where 'typ' is flume.LABEL_I, flume.LABEL_O or flume.LABEL_S, get the
    given label for this process from the reference monitor."""
    return Label (fli._get_label (typ))

##-----------------------------------------------------------------------

def get_endpoint_info ():
    """Get the endpoint information for the calling process."""
    return EndpointSet (fli._get_endpoint_info())

##-----------------------------------------------------------------------

def get_labelset ():
    """Get the labelset for this process."""
    return LabelSet (fli._get_labelset())

##-----------------------------------------------------------------------

def get_fd_label (typ, fd):
    """Same as 'get_label', but get the label for a specific FD."""
    l = fli._get_fd_label (typ, fd)

    if l is None:
        # If l was NULL but the RM returned ENULL, that means that no
        # label was set on this fd, which is not an error condition
        if flume.get_errno () != flume.ENULL:
            raise_err ("get_fd_label failure");
    else:
        l = Label (l)
    return l

##-----------------------------------------------------------------------

def stat_group (h):
    """Determine the label on the object corresponding to the group
    given by 'h'."""
    ls = fli._stat_group (h)
    if ls is None:
        raise_err ("error in stat_group (%)" % h)
    return LabelSet (ls)

##-----------------------------------------------------------------------

def stat_file (fn):
    """Ask the RM for the labelset on the file given by the filename 'fn'."""
    ls = fli._stat_file (fn)
    if ls is None:
        raise_err ("error in stat_file(%s)" % fn)
    return LabelSet (ls)

##-----------------------------------------------------------------------

def new_handle (opts, name):
    """
    Create a new handle from the reference monitor, with the given
    'opts' options and the given name 'name'.  'opts' should be a
    bitwise OR of:

       flume.HANDLE_OPT_DEFAULT_ADD
       flume.HANDLE_OPT_DEFAULT_SUBTRACT
       flume.HANDLE_OPT_PERSISTENT
       flume.HANDLE_OPT_IDENTIFIER

    Return a new flmos.Handle object, or raise an exception if there
    was a problem.
    """
    return Handle(fli._new_handle (opts, name))

##-----------------------------------------------------------------------

def new_group (name, ls):
    """
    Create a new group of capabilities, given the 'name' of the group
    and the flmos.LabelSet object 'ls' to specify the labels on the group.

    Return a new handle that identifies the group (generated by the
    reference monitor).
    """
    h = Handle(fli._new_group (name, ls))
    return h

##-----------------------------------------------------------------------

def add_to_group (h, v):
    """
    Given the handle 'h' that names a group, add the capabilities in the
    list 'v' to the group.
    """
    if type (v) is list:
        lst = Label (v)
    else:
        lst = v
    if fli._add_to_group (h, lst) < 0:
        raise_err ("add (%s) to group (%s) failed" % (str (h), str (lst)))

##-----------------------------------------------------------------------

def unixsocket (fn, c):
    fd = fli._unixsocket (fn, c)
    if fd < 0:
        raise_err ("unixsocket failed: " + fn)
    return fd

##-----------------------------------------------------------------------

def unixsocket_connect (fn):
    fd = fli._unixsocket_connect (fn)
    if fd < 0:
        raise_err ()
    return fd

##-----------------------------------------------------------------------

def listen (fd, queue_len):
    rc = fli._listen (fd, queue_len)
    if rc < 0:
        raise_err ()
    return rc

##-----------------------------------------------------------------------

def accept (fd):
    rc = fli._accept (fd)
    if rc < 0:
        raise_err ()
    return rc

##-----------------------------------------------------------------------

def make_login (h, duration=0, fixed=False):
    tok = fli._make_login (h, duration, fixed)
    if tok is None:
        raise_err ("make_login failed")
    return tok

##-----------------------------------------------------------------------

def req_privs (h, tok):
    rc = fli._req_privs (h, tok)
    if rc < 0:
        if flume.get_errno () == flume.ENOENT:
            raise flume.LoginError, \
                  "No login token found for pair (%s,'%s')" % (str (h), tok)
        elif flume.get_errno () == flume.EEXPIRED:
            raise flume.ExpirationError, \
                  "Login token expired for pair (%s,'%s')" % (str (h), tok)
        else:
            raise_err ("req_privs (%s,%s)" % (str (h), tok))

##-----------------------------------------------------------------------

def dearmor_token (x):
    t = fli._dearmor_token (x)
    if t is None:
        raise_err ("dearmor")
    return t

##-----------------------------------------------------------------------

def setuid_handle ():
    h = fli._setuid_handle ()
    if h is None:
        raise_err ("setuid_handle")
    return Handle (h)

##-----------------------------------------------------------------------

def make_nickname (h, name):
    rc = fli._make_nickname (h, name)
    if rc != 0:
        raise_err ("make_nickname")

##-----------------------------------------------------------------------

def writefile (name, data, mode=0600, labelset=None):
    flags = posix.O_WRONLY | posix.O_CREAT | posix.O_TRUNC
    rc = fli._writefile (name, flags, mode, labelset, data)
    if rc < 0:
        raise_err ("writefile failed on '%s'" % name)
        
##-----------------------------------------------------------------------

def open (name, flags='r', mode=0, labelset=None, endpoint=None, bufsize=4096):
    
    py_fl = ""
    c_fl = 0

    map = { "w" : (posix.O_WRONLY, True),
            "r" : (posix.O_RDONLY, True),
            "a" : (posix.O_APPEND, True),
            "c" : (posix.O_CREAT, False),
            "e" : (posix.O_EXCL, False),
            "t" : (posix.O_TRUNC, False)}

    for c in flags:
        p = map.get (c)
        if p is None:
            raise ValueError, "Unknown flag to open: '%s'" % c
        c_fl |=  p[0]
        if p[1]:
            py_fl += c
        
    fd = fli._open (name, c_fl, mode, labelset, endpoint)
    if fd < 0:
        raise_err ("open failed on file '%s'" % name)
            
    return posix.fdopen (fd, py_fl, bufsize)


##-----------------------------------------------------------------------

def mkdir (path, mode=0700, labelset=None):
    rc = fli._mkdir (path, mode, labelset) 
    if rc < 0:
        raise_err ("mkdir failed on file '%s'" % path)

##-----------------------------------------------------------------------

def symlink (contents, newfile, labelset=None):
    rc = fli._symlink (contents, newfile, labelset)
    if rc < 0:
        raise_err ("symlink failed on file '%s'" % newfile)
##-----------------------------------------------------------------------

def optimal_label_changes (from_ls, to_ls):
    changelist = []

    # get all caps (Do this before adding any I tags, since that might
    # prevent us from reading our capability groups).
    all_o = set(from_ls.get_O ()) | set (to_ls.get_O ())
    changelist.append (LabelChange (lab=Label (all_o), which=flume.LABEL_O))

    changelist.append (LabelChange (lab=to_ls.get_S (), which=flume.LABEL_S))
    changelist.append (LabelChange (lab=to_ls.get_I (), which=flume.LABEL_I))
    changelist.append (LabelChange (lab=to_ls.get_O (), which=flume.LABEL_O))
    return LabelChangeSet (changelist)

def spawn (prog, argv, env=None, confined=True, opt=0, claim=None,
           I_min=None, endpoint=None, ch_endpoint=None, labelset=None):
    """The original spawn; accepts a labelset for the child process
    and returns just a handle -- the pid of the child process --
    on success."""

    lchanges = None
    if labelset is not None:
        lchanges = optimal_label_changes (get_labelset (), labelset)

    tmp = spawn2 (prog=prog,
                  argv=argv,
                  env=env,
                  confined=confined,
                  opt=opt,
                  claim=claim,
                  lchanges=lchanges,
                  I_min=I_min,
                  endpoint=endpoint,
                  ch_endpoint=ch_endpoint)
    if tmp is None:
        raise_err ("Spawn failed on program '%s'" % prog)
        
    return tmp[0]

##-----------------------------------------------------------------------

def spawn2 (prog, argv, env=None, confined=True, opt=0, claim=None,
            lchanges=None, I_min=None, endpoint=None, ch_endpoint=None):
    """The new spawn procedure.  Accepts a vector of label changes
    to make, and returns a pair. The first element in the pair
    is the pid of the child process (in Handle form).  The
    second element is the status, either SPAWN_OK=0 or SPAWN_DISAPPEARED."""
    cl=None
    if env is None:
       env = os.environ
    if claim is not None:
        cl = Label (claim)
    if confined:
        opt |= fli.SPAWN_CONFINED

    tmp = fli._spawn (prog, Argv (argv), Argv (env), opt, cl, lchanges,
                      I_min, endpoint, ch_endpoint)
    if tmp is None:
        raise_err ("Spawn failed on program '%s'" % prog)

    return (Handle (tmp.gethandle ()), tmp.getfd ())

##-----------------------------------------------------------------------

def socketpair (duplex = fli.DUPLEX_FULL, desc = None):
    sp = fli._socketpair (fli.DUPLEX_FULL, desc)
    if sp is None:
        raise_err ("socketpair")
    return (sp.getfd (), Handle (sp.gethandle ()))

##-----------------------------------------------------------------------

def rpipe (desc = None):
    return socketpair (fli.DUPLEX_THEM_TO_ME, desc)

##-----------------------------------------------------------------------

def wpipe (desc = None):
    return socketpair (fli.DUPLEX_ME_TO_THEM, desc)

##-----------------------------------------------------------------------

def claim (s, desc = None):
    fd = fli._claim (Handle (s), desc)
    if fd < 0:
        raise_err ("claim")
    return fd

##-----------------------------------------------------------------------

def waitpid (h=None, opt = 0):
    pr = fli._waitpid (h, opt)
    if pr is None:
        raise_err ("waitpid")
    return (Handle (pr._get_pid (), "exitpid"), pr._get_exit_code (),
            pr._get_visible())

##-----------------------------------------------------------------------

def apply_filter (name, typ):
    f = fli._apply_filter (name, typ)
    if f is None:
        raise_err ("applying filter: %s" % name)
    return Filter (f)

##-----------------------------------------------------------------------

def closed_files ():
    if fli._closed_files () < 0:
        raise_err ("closed_files")

##-----------------------------------------------------------------------

def unlink (path):
    rc = fli._unlink (path) 
    if rc < 0:
        raise_err ("unlink failed on file '%s'" % path)

##-----------------------------------------------------------------------

def set_libc_interposing (v):
    rc = fli._set_libc_interposing (v)
    if (rc <0):
        raise_err ('unable to set libc interposing to %d' % v)

##-----------------------------------------------------------------------

def get_libc_interposing ():
    return bool (fli._libc_interposing ())

##-----------------------------------------------------------------------
def myctlsock ():
    return fli._ctl_sock ()

##-----------------------------------------------------------------------

def close (fd):
    if fli._close (fd) < 0:
        raise_err ('error closing fd %d' % fd)

##-----------------------------------------------------------------------

def flume_null ():
    r = fli._flume_null ();
    if r < 0:
        raise_err ('error calling flume_null')
    return r

##-----------------------------------------------------------------------

def flume_debug_msg (s):
    r = fli._flume_debug_msg (s);
    if r < 0:
        raise_err ('error calling flume_debug_msg')
    return r

##-----------------------------------------------------------------------

def verify_capabilities (fd, ops, caps):
    res = fli._verify_capabilities (fd, ops, caps)
    if res is None:
        raise_err ('error in verify_capabilities')
    return CapabilityOpSet (res)

##-----------------------------------------------------------------------

def send_capabilities (fd, caps):
    r = fli._send_capabilities (fd, caps)
    if r < 0:
        raise_err ('error in send_capabilities')

##-----------------------------------------------------------------------

def fork (fds, confined):
    if type (fds) is list:
        fds = IntArr (fds)
    rc = fli._flume_fork (fds, confined)
    if rc < 0:
        raise_err ('error in flume_fork')
    return rc

##-----------------------------------------------------------------------

def setepopt (fd, strict=None, fix=None):
    op = val = 0
    if fix is not None and fix is True:
        op = flume.FLUME_EP_OPT_FIX
        val = True
    elif strict is not None:
        op = flume.FLUME_EP_OPT_STRICT
        val = strict
    else:
        raise TypeError, "unknown option given to setepopt"
    rc = fli._setepopt (fd, op, val)
    if rc < 0:
        raise_err ('error in setepopt')

##-----------------------------------------------------------------------
##-----------------------------------------------------------------------


