#!/usr/bin/env python

# Copyright 2007 Maxwell Krohn
# Distributed under the GNU General Public License.
#
# A version of Bryan Ford's mergedep.pl, that handles multiple files on the
# LHS of a dependency, and also uses Python Regexes.
#
# Usage: mergedep.py <main-depfile> [<new-depfiles> ...]
#
# This script merges the contents of all <new-depfiles> specified
# on the command line into the single file <main-depfile>,
# which may or may not previously exist.
# Dependencies in the <new-depfiles> will override
# any existing dependencies for the same targets in <main-depfile>.
# The <new-depfiles> are deleted after <main-depfile> is updated.
#
# The <new-depfiles> are typically generated by GCC with the -MD option,
# and the <main-depfile> is typically included from a Makefile,
# as shown here for GNU 'make':
#
#	.deps: $(wildcard *.d)
#		python mergedep.py $@ $^
#	-include .deps
#
# This script properly handles multiple dependencies per <new-depfile>,
# including dependencies having no target,
# so it is compatible with GCC3's -MP option.
#

import sys
import os
import os.path
import re

##-----------------------------------------------------------------------

class DepError (Exception):
    def __init__ (self, value):
        self.value = value
    def __str__ (self):
        return repr (self.value)
    
##-----------------------------------------------------------------------

class DepFile:
    """Given an filename, open a file handle and wrap it with this
    little class, that just keeps track of line numbers, and also has
    a slighlty higher-level readline function (one that reads over
    trailing '\' characters)."""

    _line_re = re.compile ("^.*\\\\\s*")
    _comment_re = re.compile ("^([^#\n]+)(#[^\n]+)")

    def __init__ (self, file):
        self._fh = open (file, "r")
        self._lineno = 1
        self._has_data = True

    def lineNumber (self):
        return self._lineno

    def hasData (self):
        return self._has_data

    def readLine (self):
        """Get the next logical line, reading over many lines that end
        in '\'."""
        
        go = True
        dat = ""
        while go and self._has_data:
            line = self._fh.readline ()
            m = self._comment_re.match (line)
            if m is not None:
                line = m.groups (1)
            self._lineno += 1
            if len(line) == 0:
                self._has_data = False
            else:
                dat += line
                if self._line_re.match (line) is None:
                    go = False

        return dat

##-----------------------------------------------------------------------

files_split_re = re.compile ('[\s\n\\\\]+')

def files_split (input):
    """Given a line of input with many files on it, split into an array
    with appropriately stripped files names."""
    ret = []
    for f in [ f.strip() for f in files_split_re.split (input) ] :
        if len (f) > 0:
            ret += [f]
    return ret

##-----------------------------------------------------------------------

def readdeps (file, dephash):
    """Read a whole file, getting its dependencies, and outputting the
    dependencies to the hash that was passed in as an argument."""

    # no prob, just skip it
    if not os.path.exists (file):
        return

    # this is a prob, and we need to report it
    if not os.path.isfile (file):
        raise DepError, "%s: bad file given" % file

    myfile = DepFile (file)

    while myfile.hasData():

        lineno = myfile.lineNumber()
        line = myfile.readLine ()
        tup = line.split (':')
        
        if len (tup) == 2:
            
            keys = files_split (tup[0])
            values = set (files_split (tup[1]))
                    
            if len(keys) == 0:
                raise DepError, "%s:%d: bad dependency" % (file, lineno)
            
            for k in keys:
                try:
                    dephash[k] |= values
                except KeyError:
                    dephash[k] = values
                    
        elif len (tup) > 2:
            raise DepError, "%s:%d: bad dependency" % (file, lineno)
        elif len (tup) == 1:
            v = tup[0]
            if len (v.strip()) != 0:
                raise DepError, "%s:%d: bad dependency" % (file, lineno)
        elif len (tup) == 0:
            # empty line, let's ignore it
            pass

##-----------------------------------------------------------------------

def pretty_format (lst, cols):
    """Use minimal number of lines, while still not wrapping.  Note
    some wraps are unavoidable since file names can be quite long.
    This is the epitome is worthless anality."""
    
    tmp = []
    
    for x in lst:
        
        if len (tmp) == 0 or \
           (tmp[-1][0] != 0 and tmp[-1][0] + len(x) + 1 > cols):
            
            tmp += [ [0, []] ]
            
        tmp[-1][0] += len (x) + 1
        tmp[-1][1] += [ x ]

    return " \\\n  ".join ([ ' '.join (t[1]) for t in tmp ])

##-----------------------------------------------------------------------
## Main section
##
            
if len (sys.argv) < 2:
    print "usage: %s <main-depfile> [<new-depfiles> ...]\n" % (sys.argv[0])
    sys.exit (1)

dephash = {}
maindeps = sys.argv[1]
readdeps (maindeps, dephash)

for f in sys.argv[2:]:
    readdeps (f, dephash)

tmpname = maindeps + ".tmp"
tmp = open (tmpname, "w")

keys = dephash.keys ()
keys.sort ()

for k in keys:
    tmp.write (pretty_format ([k + ":"] + list(dephash[k]), 75) + "\n")

tmp.close ()
os.rename (tmpname, maindeps)

for f in sys.argv[2:]:
    os.unlink (f)
